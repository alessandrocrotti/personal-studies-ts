name: Build & Push my-example docker images

on:
  push:
    # Esegui solamente se variano i seguenti file
    paths:
      - "src/devops/docker/my-example-image/backend/package.json"
      - "src/devops/docker/my-example-image/frontend/VERSION"
      - ".github/workflows/my-example-image-docker.yml"
  workflow_dispatch:

env:
  IMAGE_NAMESPACE: ${{ secrets.DOCKERHUB_USERNAME  }}

jobs:
  build-backend:
    runs-on: ubuntu-latest
    defaults:
      run:
        # Definiamo come cartella di partenza quella di backend per tutti gli step di questo job di tipo "run" (cioè i comandi da shell)
        working-directory: ./src/devops/docker/my-example-image/backend
    steps:
      - uses: actions/checkout@v4
        with:
          # Recupera non solo il primo livello del repo dove ci sono i file correnti ma anche il secondo livello, cioè "HEAD^" che sarebbe l'history del file precedente
          fetch-depth: 2

      - name: Check backend version change
        id: check_be
        run: |
          git log --oneline -n 3
          git show HEAD^:src/devops/docker/my-example-image/backend/package.json || echo "file non trovato"
          CURRENT=$(jq -r .version package.json)
          # Recupera da git il file package.json, utilizzando HEAD^ si prende il commit precedente all'ultimo eseguito, 
          # 2>/dev/null reindirizza gli eventuali errori (2 indica l'output di error) nel "null device" per non mostrarli (/dev/null è un file speciale che se ci scrivi sopra il contenuto sparisce)
          # jq -r .version: jq converte in json il package.json (-r rimove le virgolette dai valori di stringa del json)
          #PREV=$(git show HEAD^:src/devops/docker/my-example-image/backend/package.json 2>/dev/null | jq -r .version)
          PREV=temp
          echo "Current backend version: $CURRENT"
          echo "Previous backend version: $PREV"

          # Verifica se la condizione CURRENT != PREF e tramite echo valorizza CHANGED che oi mette in OUTPUT
          CHANGED=$([[ "$CURRENT" != "$PREV" ]] && echo true || echo false)
          # Aggiungo un output a questo step con chiave "changed" e valore il valore di CHANGED
          echo "changed=$CHANGED" >> "$GITHUB_OUTPUT"
          # Aggiungo un output a questo step con chiave "version" e valore il valore di CURRENT
          echo "version=$CURRENT" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        # Esegui questo step solo se check_be changed è true
        if: steps.check_be.outputs.changed == 'true'
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        # Esegui questo step solo se check_be changed è true
        if: steps.check_be.outputs.changed == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Calculate Docker Tag list
        # Esegui questo step solo se check_be changed è true
        if: steps.check_be.outputs.changed == 'true'
        id: tags
        run: |
          # Estraggo la version, la divido per il valore punto (-d.) e prendo il primo valore per MAJOR e il secondo per MINOR
          VERSION=${{ steps.check_be.outputs.version }}
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          # Creo il valore dell'immagine
          IMAGE="$IMAGE_NAMESPACE/my-example-image-be"
          # Creo un tag per ogni livello di versione "image:1.2.3,image:1.2,image:1"
          TAGS="${IMAGE}:${VERSION},${IMAGE}:${MAJOR}.${MINOR},${IMAGE}:${MAJOR}"

          # Condizione per latest (ad es. solo su main)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            TAGS="$TAGS,${IMAGE}:latest"
          fi

          # Aggiungo tags all'output
          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"

      - name: Build and push backend
        # Esegui questo step solo se check_be changed è true
        if: steps.check_be.outputs.changed == 'true'
        uses: docker/build-push-action@v6
        with:
          # Serve il path esteso, perchè la "working-directory" definita vale solo per i comandi eseguiti da shell e non nei parametri delle action
          file: ./src/devops/docker/my-example-image/backend/Dockerfile.multistage
          # Segnare la cartellacome context, perchè il default e puntare al repository stesso dall'action e non sarebbe corretto nel nostro contesto
          context: ./src/devops/docker/my-example-image/backend
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          # Gestisce la cache dei vari layer dell'immagine su github action in modo che rende più veloce l'esecuzione successiva (mantenuta per 7 giorni)
          cache-from: type=gha
          cache-to: type=gha,mode=max

  build-frontend:
    runs-on: ubuntu-latest
    defaults:
      run:
        # Definiamo come cartella di partenza quella di frontend per tutti gli step di questo job di tipo "run" (cioè i comandi da shell)
        working-directory: ./src/devops/docker/my-example-image/frontend
    steps:
      - uses: actions/checkout@v4
        with:
          # Recupera non solo il primo livello del repo dove ci sono i file correnti ma anche il secondo livello, cioè "HEAD^" che sarebbe l'history del file precedente
          fetch-depth: 2

      - name: Check frontend version change
        id: check_fe
        run: |
          git log --oneline -n 3
          git show HEAD^:src/devops/docker/my-example-image/frontend/VERSION || echo "file non trovato"
          # Recupera il contenuto del file VERSION in cui è segnata la versione del progetto
          CURRENT=$(cat VERSION)
          # Recupera da git il file VERSION, utilizzando HEAD^ si prende il commit precedente all'ultimo eseguito, 
          # 2>/dev/null reindirizza gli eventuali errori (2 indica l'output di error) nel "null device" per non mostrarli (/dev/null è un file speciale che se ci scrivi sopra il contenuto sparisce)
          #PREV=$(git show HEAD^:src/devops/docker/my-example-image/frontend/VERSION 2>/dev/null)
          PREV=temp
          echo "Current frontend version: $CURRENT"
          echo "Previous frontend version: $PREV"

          if [ "$CURRENT" = "$PREV" ]; then
            # Messaggio con pattern "::notice title=Titolo::Testo" che viene scritto nell'interfaccia dell'action
            echo "::notice title=Skip job::No frontend version change detected"
            # Codice di uscita interpretato dall'actions/runner come "job skipped" in modo da evitare gli step successivi 
            # Scelto di fare in questo modo per mostrare un modo possibile per faro
            exit 78
          fi
          # Aggiungo un output a questo step con chiave "version" e valore il valore di CURRENT
          echo "version=$CURRENT" >> "$GITHUB_OUTPUT"

      - name: Set up Docker Buildx
        # Salta questo se step check_fe non è "success", per esempio è fallito oppure è skippato tramite l'exit 78
        if: steps.check_fe.outcome == 'success'
        uses: docker/setup-buildx-action@v3

      - name: Login to Docker Hub
        # Salta questo se step check_fe non è "success", per esempio è fallito oppure è skippato tramite l'exit 78
        if: steps.check_fe.outcome == 'success'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Calculate Docker Tag list
        # Salta questo se step check_fe non è "success", per esempio è fallito oppure è skippato tramite l'exit 78
        if: steps.check_fe.outcome == 'success'
        id: tags
        run: |
          # Estraggo la version, la divido per il valore punto (-d.) e prendo il primo valore per MAJOR e il secondo per MINOR
          VERSION=${{ steps.check_fe.outputs.version }}
          MAJOR=$(echo "$VERSION" | cut -d. -f1)
          MINOR=$(echo "$VERSION" | cut -d. -f2)
          # Creo il valore dell'immagine
          IMAGE="$IMAGE_NAMESPACE/my-example-image-fe"
          # Creo un tag per ogni livello di versione "image:1.2.3,image:1.2,image:1"
          TAGS="${IMAGE}:${VERSION},${IMAGE}:${MAJOR}.${MINOR},${IMAGE}:${MAJOR}"

          # Condizione per latest (ad es. solo su main)
          if [ "${{ github.ref }}" = "refs/heads/main" ]; then
            TAGS="$TAGS,${IMAGE}:latest"
          fi

          # Aggiungo tags all'output
          echo "tags=$TAGS" >> "$GITHUB_OUTPUT"

      - name: Build and push frontend
        if: steps.check_fe.outcome == 'success' && steps.tags.outcome == 'success'
        uses: docker/build-push-action@v6
        with:
          # Serve il path esteso, perchè la "working-directory" definita vale solo per i comandi eseguiti da shell e non nei parametri delle action
          file: ./src/devops/docker/my-example-image/frontend/Dockerfile
          # Segnare la cartellacome context, perchè il default e puntare al repository stesso dall'action e non sarebbe corretto nel nostro contesto
          context: ./src/devops/docker/my-example-image/frontend
          push: true
          tags: ${{ steps.tags.outputs.tags }}
          # Gestisce la cache dei vari layer dell'immagine su github action in modo che rende più veloce l'esecuzione successiva (mantenuta per 7 giorni)
          cache-from: type=gha
          cache-to: type=gha,mode=max
